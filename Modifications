#!/usr/bin/env Rscript

# =========================================================
# SampleTree (sample-based, with Y-targets & N in tree)
# + clade-wise TREND (limma or MaAsLin2) and boxplots
#
# Driven by:
#   methods.txt, sampletree_control.txt, target.txt
# =========================================================

suppressPackageStartupMessages({
  libs <- c(
    "optparse","ape","vegan","picante","phyloseq","phangorn","progress",
    "ggplot2","ggtree","treeio","dplyr","readr","stringr","tibble","tools",
    "reshape2","limma"
  )
  miss <- libs[!(libs %in% installed.packages()[,"Package"])]
  if (length(miss)) install.packages(miss, repos = "https://cran.rstudio.com/")
  lapply(libs, require, character.only = TRUE)
})
message("✓ Environment ready.")

# ---------------------------------------------------------
# 1. Helpers
# ---------------------------------------------------------

get_script_dir <- function(){
  ca <- commandArgs(trailingOnly = FALSE)
  file_arg <- grep("^--file=", ca, value = TRUE)
  if (length(file_arg)) {
    return(dirname(normalizePath(sub("^--file=", "", file_arg[1]))))
  }
  getwd()
}

script_dir <- get_script_dir()

read_control <- function(path){
  if (!file.exists(path)) stop("Control file not found: ", path)
  lines <- readLines(path, warn = FALSE, encoding = "UTF-8")
  strip <- function(s){
    s <- gsub("\\r", "", s, perl = TRUE)
    s <- sub("\\s*#.*$", "", s, perl = TRUE)
    trimws(s)
  }
  lines <- vapply(lines, strip, "", USE.NAMES = FALSE)
  lines <- lines[nchar(lines) > 0]
  cfg <- new.env(parent = emptyenv())
  for (ln in lines){
    kv <- strsplit(ln, "=", fixed = TRUE)[[1]]
    if (length(kv) < 2) next
    key <- tolower(trimws(kv[1]))
    val <- trimws(paste(kv[-1], collapse = "="))
    assign(key, val, envir = cfg)
  }
  cfg
}

cfg_get_int <- function(cfg, key){
  if (!exists(key, envir = cfg, inherits = FALSE)) {
    stop("Required integer setting missing in sampletree_control.txt: ", key)
  }
  v <- get(key, envir = cfg, inherits = FALSE)
  out <- suppressWarnings(as.integer(v))
  if (is.na(out)) stop("Invalid integer for ", key, " = ", v)
  out
}

cfg_get_chr <- function(cfg, key, default = NULL){
  if (!exists(key, envir = cfg, inherits = FALSE)) return(default)
  as.character(get(key, envir = cfg, inherits = FALSE))
}

ensure_dir <- function(d){
  if (!dir.exists(d)) dir.create(d, recursive = TRUE, showWarnings = FALSE)
}

trim_vec <- function(x){
  x <- stringr::str_trim(x)
  x[nchar(x) > 0 & !x %in% c("NA","NaN","N/A","null","None")]
}

split_samples <- function(s){
  if (is.null(s) || length(s) == 0 || all(is.na(s))) return(character(0))
  trim_vec(unlist(stringr::str_split(as.character(s), ",")))
}

resolve_path <- function(path){
  path <- trimws(path)
  if (grepl("^[A-Za-z]:", path) || grepl("^/", path)) {
    return(path)                  # absolute path
  }
  file.path(script_dir, path)     # relative to script dir
}

resolve_tree_path <- function(tree_raw){
  tree_raw <- trimws(tree_raw)
  if (!nchar(tree_raw) || tree_raw %in% c("NA","Na","na")) return(NA_character_)
  # try as given
  p1 <- resolve_path(tree_raw)
  if (file.exists(p1)) return(p1)
  # try adding .nwk
  p2 <- resolve_path(paste0(tree_raw, ".nwk"))
  if (file.exists(p2)) return(p2)
  NA_character_
}

matrix_label_from_file <- function(file_str){
  # just use the CSV basename without extension; can be anything
  tools::file_path_sans_ext(basename(file_str))
}

# ---------------------------------------------------------
# 2. Load configs + support files
# ---------------------------------------------------------

# thresholds from sampletree_control.txt
control_file <- file.path(script_dir, "sampletree_control.txt")
if (!file.exists(control_file)) {
  stop("sampletree_control.txt not found in script dir: ", control_file)
}
cfg_thr <- read_control(control_file)

thr_min_targeted <- cfg_get_int(cfg_thr, "min_targeted")
thr_max_clade    <- cfg_get_int(cfg_thr, "max_clade_size")
thr_max_others   <- cfg_get_int(cfg_thr, "max_others")
assign_policy    <- cfg_get_chr(cfg_thr, "assign_policy", "best")

message("Thresholds: min_targeted = ", thr_min_targeted,
        ", max_clade_size = ", thr_max_clade,
        ", max_others = ", thr_max_others,
        ", assign_policy = ", assign_policy)

# target.txt → Y / N labels
target_file <- file.path(script_dir, "target.txt")
if (!file.exists(target_file)) {
  stop("target.txt not found in script dir: ", target_file)
}
target_df <- read.delim(target_file,
                        sep = "\t",
                        stringsAsFactors = FALSE,
                        check.names = FALSE)
if (!all(c("Sample","Target") %in% names(target_df))) {
  stop("target.txt must have columns 'Sample' and 'Target'")
}
target_df$Target <- toupper(trimws(target_df$Target))
target_yes <- target_df$Sample[target_df$Target == "Y"]
message("Target samples (Y): ", length(target_yes))

# methods.txt → jobs
methods_file <- file.path(script_dir, "methods.txt")
if (!file.exists(methods_file)) {
  stop("methods.txt not found in script dir: ", methods_file)
}
methods_df <- read.table(methods_file,
                         header = TRUE,
                         stringsAsFactors = FALSE,
                         check.names = FALSE)
req_cols <- c("File","Method","Boot","Library","Tree")
if (!all(req_cols %in% names(methods_df))) {
  stop("methods.txt must have columns: File, Method, Boot, Library, Tree")
}

valid_methods <- c("Bray","MPD","MNTD","MPDw","MNTDw","UniFrac","UniFracW","MMU")
phylo_methods <- setdiff(valid_methods, c("Bray","MMU"))

# ---------------------------------------------------------
# 3. CLI: out-root + optional global tree fallback
# ---------------------------------------------------------

opt <- list(
  make_option(c("--tree"), type = "character", default = NULL,
              help = "Global .nwk tree path (fallback) for phylogenetic methods."),
  make_option(c("--out-root"), type = "character", default = NULL,
              help = "Root output directory. Default: alongside each input CSV.")
)

args <- parse_args(OptionParser(option_list = opt))

global_tree_path <- args$tree
if (!is.null(global_tree_path) && nchar(global_tree_path)) {
  global_tree_path <- normalizePath(global_tree_path, mustWork = TRUE)
}

# ---------------------------------------------------------
# 4. Tree + clade helpers (with contamination + highlighting)
# ---------------------------------------------------------

get_tip_descendants <- function(tree, node){
  if (node <= length(tree$tip.label)) return(tree$tip.label[node])
  desc <- c(node); to_visit <- node
  while (length(to_visit) > 0){
    cur <- to_visit[1]
    kids <- tree$edge[tree$edge[,1] == cur, 2]
    desc <- c(desc, kids)
    to_visit <- c(to_visit[-1], kids[kids > length(tree$tip.label)])
  }
  tree$tip.label[sort(desc[desc <= length(tree$tip.label)])]
}

plot_tree_basic <- function(tree, file, title){
  ok <- FALSE
  # try ggtree first
  try({
    p <- ggtree(tree) +
      geom_tiplab(size = 3) +
      ggtitle(title) +
      theme(plot.title = element_text(hjust = 0.5))
    ggsave(file, p, width = 10, height = 10, units = "in", dpi = 300)
    ok <- TRUE
  }, silent = TRUE)
  if (ok) return(invisible(NULL))
  
  # fallback
  message("  (ggtree basic plot failed; using base ape::plot.phylo instead)")
  try({
    grDevices::jpeg(file, width = 10, height = 10, units = "in", res = 300)
    par(mar = c(1,1,3,1))
    plot(tree, main = title, cex = 0.5)
    grDevices::dev.off()
  }, silent = TRUE)
  invisible(NULL)
}

plot_highlighted_tree <- function(tree, targeted_set, contamination_set,
                                  outfile, tag, method){
  tips_all <- tree$tip.label
  cols <- setNames(rep("black", length(tips_all)), tips_all)
  
  cols[intersect(names(cols), contamination_set)] <- "blue"  # others in contaminated clades
  cols[intersect(names(cols), targeted_set)]      <- "red"   # targeted Y override
  
  ok <- FALSE
  tip_df <- data.frame(label = names(cols), color = cols)
  try({
    p <- ggtree(tree) %<+% tip_df +
      geom_tiplab(aes(color = color), size = 3) +
      geom_tippoint(aes(color = color), size = 3) +
      scale_color_identity() +
      ggtitle(paste0(
        "SampleTree ", tag, " (", method, ")\n",
        "Red = Targeted (Y), Blue = contamination, Black = other"
      )) +
      theme(plot.title = element_text(hjust = 0.5))
    ggsave(outfile, p, width = 12, height = 12, units = "in", dpi = 300)
    ok <- TRUE
  }, silent = TRUE)
  if (ok) return(invisible(NULL))
  
  message("  (ggtree highlighted plot failed; using base ape::plot.phylo instead)")
  try({
    grDevices::jpeg(outfile, width = 12, height = 12, units = "in", res = 300)
    par(mar = c(1,1,3,1))
    plot(tree, main = paste("SampleTree", tag, "(", method, ")"),
         cex = 0.5, tip.color = cols[tree$tip.label])
    legend("topleft",
           legend = c("Targeted (Y)", "Contamination", "Other"),
           col    = c("red","blue","black"),
           pch    = 16, bty = "n", cex = 0.8)
    grDevices::dev.off()
  }, silent = TRUE)
  invisible(NULL)
}

bootstrap_reads <- function(otu){
  boot <- otu
  for (i in seq_len(nrow(otu))){
    reads <- as.numeric(otu[i,])
    tot <- sum(reads, na.rm = TRUE)
    if (tot > 0){
      prob <- reads / tot
      boot[i,] <- rmultinom(1, tot, prob)
    }
  }
  as.data.frame(boot)
}

run_tree_analysis <- function(method, data, ref_tree, do_boot, nboot, outdir, outprefix){
  dist <- switch(method,
                 "Bray"    = vegan::vegdist(data, method = "bray", na.rm = TRUE),
                 "MPD"     = picante::comdist(data,  cophenetic(ref_tree), abundance.weighted = FALSE),
                 "MNTD"    = picante::comdistnt(data, cophenetic(ref_tree), abundance.weighted = FALSE),
                 "MPDw"    = picante::comdist(data,  cophenetic(ref_tree), abundance.weighted = TRUE),
                 "MNTDw"   = picante::comdistnt(data, cophenetic(ref_tree), abundance.weighted = TRUE),
                 "UniFrac" = phyloseq::distance(
                   phyloseq::phyloseq(phyloseq::otu_table(t(data), taxa_are_rows = TRUE), ref_tree),
                   method = "unifrac"),
                 "UniFracW"= phyloseq::distance(
                   phyloseq::phyloseq(phyloseq::otu_table(t(data), taxa_are_rows = TRUE), ref_tree),
                   method = "wunifrac")
  )
  
  tr <- ape::nj(dist)
  tr$edge.length[tr$edge.length < 0] <- 0
  
  if (isTRUE(do_boot) && method != "Bray"){
    cat("  Bootstrapping (", nboot, ")\n", sep = "")
    boots <- vector("list", nboot)
    pb <- progress::progress_bar$new(total = nboot, format = "  [:bar] :percent :eta")
    for (i in seq_len(nboot)){
      pb$tick()
      b <- bootstrap_reads(data)
      d <- switch(method,
                  "MPD"     = picante::comdist(b,  cophenetic(ref_tree), abundance.weighted = FALSE),
                  "MNTD"    = picante::comdistnt(b, cophenetic(ref_tree), abundance.weighted = FALSE),
                  "MPDw"    = picante::comdist(b,  cophenetic(ref_tree), abundance.weighted = TRUE),
                  "MNTDw"   = picante::comdistnt(b, cophenetic(ref_tree), abundance.weighted = TRUE),
                  "UniFrac" = phyloseq::distance(
                    phyloseq::phyloseq(phyloseq::otu_table(t(b), taxa_are_rows = TRUE), ref_tree),
                    method = "unifrac"),
                  "UniFracW"= phyloseq::distance(
                    phyloseq::phyloseq(phyloseq::otu_table(t(b), taxa_are_rows = TRUE), ref_tree),
                    method = "wunifrac")
      )
      boots[[i]] <- tryCatch(ape::nj(d), error = function(e) NULL)
    }
    good <- boots[!vapply(boots, is.null, logical(1))]
    if (length(good)){
      sup <- ape::prop.clades(tr, good) / length(good) * 100
      tr$node.label <- round(sup)
    } else {
      message("  ⚠ All bootstrap replicates failed.")
    }
  }
  
  out_tree <- file.path(outdir, paste0(outprefix, "_", method, ".nwk"))
  ape::write.tree(tr, out_tree)
  plot_tree_basic(tr, gsub("\\.nwk$", ".jpeg", out_tree), paste(method, "Tree"))
  list(file = out_tree, tree = tr)
}

find_clades_global <- function(tree, tag, method, outdir,
                               min_targeted, max_clade, max_others,
                               targeted_set){
  clade_dir <- file.path(outdir, "clades")
  ensure_dir(clade_dir)
  clade_csv <- file.path(clade_dir,
                         paste0("clades_", tag, "_", method, ".csv"))
  
  tips_all      <- tree$tip.label
  targeted_set  <- intersect(tips_all, targeted_set)
  others_global <- setdiff(tips_all, targeted_set)
  
  nTips    <- length(tips_all)
  internal <- (nTips + 1):(nTips + tree$Nnode)
  
  cand <- list()
  for (nd in internal){
    desc <- get_tip_descendants(tree, nd)
    desc_u <- unique(desc)
    
    tgt_u <- intersect(desc_u, targeted_set)
    oth_u <- intersect(desc_u, others_global)
    
    n_tips <- length(desc_u)
    n_tgt  <- length(tgt_u)
    n_oth  <- length(oth_u)
    
    if (n_tips < min_targeted || n_tips > max_clade) next
    if (n_tgt  < min_targeted) next
    if (n_oth  > max_others)   next
    
    cand[[length(cand) + 1]] <- list(
      node    = nd,
      samples = desc_u,
      tgt     = tgt_u,
      oth     = oth_u,
      n_tips  = n_tips,
      n_tgt   = n_tgt,
      n_oth   = n_oth
    )
  }
  
  if (!length(cand)){
    empty_df <- data.frame(
      Tag               = character(0),
      Method            = character(0),
      Clade_Node        = integer(0),
      Clade_Name        = character(0),
      N_Tips            = integer(0),
      Targeted_Count    = integer(0),
      Others_Count      = integer(0),
      Targeted_Samples  = character(0),
      Others            = character(0),
      Contamination_Flag= character(0),
      stringsAsFactors  = FALSE
    )
    utils::write.csv(empty_df, clade_csv, row.names = FALSE)
    message("  No clades meeting thresholds. Wrote empty: ", clade_csv)
    return(list(clades = empty_df, contam_tips = character(0), kept = list()))
  }
  
  ord <- order(
    vapply(cand, function(x) -x$n_tgt, numeric(1)),
    vapply(cand, function(x)  x$n_oth, numeric(1)),
    vapply(cand, function(x)  x$n_tips, numeric(1))
  )
  assigned <- character(0)
  kept <- list()
  for (i in ord){
    ci <- cand[[i]]
    if (length(intersect(ci$samples, assigned)) == 0){
      kept[[length(kept) + 1]] <- ci
      assigned <- union(assigned, ci$samples)
    }
  }
  
  contam_union <- character(0)
  
  clade_df <- dplyr::bind_rows(lapply(kept, function(ci){
    clade_name <- paste0("node", ci$node)
    contam_flag <- ifelse(length(ci$oth) > 0, "Yes", "No")
    if (length(ci$oth) > 0) {
      contam_union <<- union(contam_union, ci$oth)
    }
    data.frame(
      Tag               = tag,
      Method            = method,
      Clade_Node        = ci$node,
      Clade_Name        = clade_name,
      N_Tips            = ci$n_tips,
      Targeted_Count    = ci$n_tgt,
      Others_Count      = ci$n_oth,
      Targeted_Samples  = if (length(ci$tgt)) paste(sort(ci$tgt), collapse = ",") else "",
      Others            = if (length(ci$oth)) paste(sort(ci$oth), collapse = ",") else "",
      Contamination_Flag= contam_flag,
      stringsAsFactors  = FALSE
    )
  }))
  
  utils::write.csv(clade_df, clade_csv, row.names = FALSE)
  message("  ✓ Wrote clades: ", clade_csv)
  
  list(clades = clade_df, contam_tips = contam_union, kept = kept)
}

# ---------------------------------------------------------
# 5. TREND helpers (limma or MaAsLin2)
# ---------------------------------------------------------

zscore_rows <- function(mat){
  mat <- as.matrix(mat)
  m <- rowMeans(mat, na.rm = TRUE)
  s <- apply(mat, 1, sd, na.rm = TRUE)
  s[s == 0 | is.na(s)] <- 1
  mat_centered <- sweep(mat, 1, m, "-")
  sweep(mat_centered, 1, s, "/")
}

plot_group_box <- function(Mat, feats, in_group_vec, group_label, out_png){
  if (!length(feats)) return(invisible(NULL))
  mat_sig <- Mat[, feats, drop = FALSE]
  long_df <- reshape2::melt(
    as.matrix(mat_sig),
    varnames  = c("SampleID", "Feature"),
    value.name = "Value"
  )
  long_df$Group <- ifelse(long_df$SampleID %in% in_group_vec, group_label, "other")
  
  p <- ggplot2::ggplot(long_df, ggplot2::aes(x = Group, y = Value, fill = Group)) +
    ggplot2::geom_boxplot(outlier.shape = NA) +
    ggplot2::geom_jitter(width = 0.2, size = 1, alpha = 0.6) +
    ggplot2::facet_wrap(~ Feature, scales = "free_y") +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::labs(
      title = paste0("Boxplots: ", group_label, " vs other"),
      x = "Group", y = "Value"
    ) +
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))
  
  ggplot2::ggsave(out_png, plot = p, width = 12, height = 7, dpi = 300)
  invisible(TRUE)
}

run_trend_for_job <- function(otu, clade_info, outdir, tag, method,
                              matrix_label, library_name,
                              fdr_cutoff = 0.01,
                              min_in_group = 2,
                              min_in_other = 2){
  if (is.null(clade_info$clades) || nrow(clade_info$clades) == 0){
    message("  (TREND:", matrix_label, "/", library_name, ") No clades; skipping.")
    return(invisible(NULL))
  }
  
  Mat <- otu  # samples x features
  trend_root <- file.path(outdir, "trend_outputs")
  ensure_dir(trend_root)
  
  all_samples <- rownames(Mat)
  kept <- clade_info$kept
  lib_lower <- tolower(library_name)
  
  for (ci in kept){
    clade_name <- paste0("node", ci$node)
    message("  (TREND:", matrix_label, "/", library_name, ") Clade ", clade_name)
    
    group_label <- clade_name
    g_safe <- make.names(paste(tag, method, clade_name, matrix_label, sep = "_"))
    g_dir  <- file.path(trend_root, paste0("group_", g_safe))
    ensure_dir(g_dir)
    
    in_clade_ids <- intersect(all_samples, ci$samples)
    grp <- ifelse(rownames(Mat) %in% in_clade_ids, group_label, "other")
    names(grp) <- rownames(Mat)
    
    n_g <- sum(grp == group_label)
    n_o <- sum(grp == "other")
    if (n_g < min_in_group || n_o < min_in_other){
      message("    - Skip (need >=", min_in_group,
              " in clade and >=", min_in_other, " in other).")
      next
    }
    
    # ---------- limma ----------
    if (lib_lower == "limma"){
      fgrp <- factor(grp, levels = c(group_label, "other"))
      design <- model.matrix(~ 0 + fgrp)
      colnames(design) <- c(make.names(group_label), "other")
      
      fit   <- limma::lmFit(t(Mat), design)
      contr <- limma::makeContrasts(
        contrasts = paste0(make.names(group_label), " - other"),
        levels = design
      )
      fit2  <- limma::eBayes(limma::contrasts.fit(fit, contr))
      res   <- limma::topTable(fit2, number = Inf, adjust.method = "fdr")
      res$Feature <- rownames(res)
      res <- dplyr::relocate(res, Feature)
      
      sig <- dplyr::filter(res, adj.P.Val < fdr_cutoff)
      if (!nrow(sig)){
        message("    - No significant features (limma); skipping.")
        next
      }
      
      sig_file_group <- file.path(
        g_dir,
        paste0("sig_features_", matrix_label, "_limma.csv")
      )
      utils::write.csv(sig, sig_file_group, row.names = FALSE)
      
      trend_df <- sig %>%
        dplyr::transmute(
          Element = Feature,
          `Observed Shift` = dplyr::case_when(
            logFC > 0  ~  1L,
            logFC < 0  ~ -1L,
            TRUE       ~  0L
          )
        )
      
      input_file <- file.path(
        g_dir,
        paste0("Input_", matrix_label, "_limma.csv")
      )
      utils::write.csv(trend_df, input_file, row.names = FALSE)
      
      feats_for_box <- intersect(trend_df$Element, colnames(Mat))
      if (length(feats_for_box) > 0){
        box_png <- file.path(
          g_dir,
          paste0(g_safe, "_limma_box.png")
        )
        plot_group_box(
          Mat,
          feats_for_box,
          in_group_vec = in_clade_ids,
          group_label  = paste0("Clade_", clade_name),
          out_png      = box_png
        )
      }
      
      sig_feats   <- intersect(sig$Feature, colnames(Mat))
      ordered_ids <- c(in_clade_ids, setdiff(rownames(Mat), in_clade_ids))
      mat_sig <- as.matrix(Mat[ordered_ids, sig_feats, drop = FALSE])
      if (nrow(mat_sig) >= 2 && ncol(mat_sig) >= 1){
        mat_sig_z <- zscore_rows(mat_sig)
        utils::write.csv(
          data.frame(SampleID = rownames(mat_sig_z), mat_sig_z, check.names = FALSE),
          file.path(g_dir, "zscore_matrix_limma.csv"),
          row.names = FALSE
        )
        hc_rows <- stats::hclust(stats::dist(mat_sig_z))
        cl_lab  <- stats::cutree(hc_rows, k = 2)
        utils::write.csv(
          data.frame(SampleID = names(cl_lab),
                     Cluster  = cl_lab,
                     check.names = FALSE),
          file.path(g_dir, "row_clusters_k2_limma.csv"),
          row.names = FALSE
        )
      }
      
      next
    }
    
    # ---------- MaAsLin2 ----------
    if (lib_lower %in% c("maaslin2","maaslin","maaslin2 ")){
      if (!requireNamespace("Maaslin2", quietly = TRUE)){
        message("    - Maaslin2 not installed; skipping TREND for this clade.")
        next
      }
      
      metadata <- data.frame(
        SampleID = rownames(Mat),
        Group    = grp,
        stringsAsFactors = FALSE
      )
      rownames(metadata) <- metadata$SampleID
      
      ma_out_dir <- file.path(g_dir, "Maaslin2_out")
      if (dir.exists(ma_out_dir)) unlink(ma_out_dir, recursive = TRUE, force = TRUE)
      
      fit <- tryCatch(
        Maaslin2::Maaslin2(
          input_data    = t(Mat),
          input_metadata= metadata,
          output        = ma_out_dir,
          fixed_effects = "Group",
          random_effects= NULL,
          normalization = "NONE",
          transform     = "NONE",
          standardize   = FALSE
        ),
        error = function(e){
          message("    - Maaslin2 error: ", conditionMessage(e))
          NULL
        }
      )
      if (is.null(fit)) next
      
      res_tab <- NULL
      if (!is.null(fit$results)){
        res_tab <- fit$results
      } else {
        res_file <- file.path(ma_out_dir, "all_results.tsv")
        if (file.exists(res_file)){
          res_tab <- tryCatch(
            read.delim(res_file, stringsAsFactors = FALSE, check.names = FALSE),
            error = function(e) NULL
          )
        }
      }
      if (is.null(res_tab) || !"qval" %in% names(res_tab)){
        message("    - No Maaslin2 results with qval; skipping.")
        next
      }
      
      res_tab <- res_tab[res_tab$metadata == "Group", , drop = FALSE]
      sig <- res_tab[!is.na(res_tab$qval) & res_tab$qval < fdr_cutoff, , drop = FALSE]
      if (!nrow(sig)){
        message("    - No significant features (Maaslin2); skipping.")
        next
      }
      
      sig_file_group <- file.path(
        g_dir,
        paste0("sig_features_", matrix_label, "_Maaslin2.csv")
      )
      utils::write.csv(sig, sig_file_group, row.names = FALSE)
      
      if (!all(c("feature","value") %in% names(sig))){
        message("    - Maaslin2 results missing 'feature' or 'value'; cannot build Input_.")
        next
      }
      
      trend_df <- data.frame(
        Element = sig$feature,
        `Observed Shift` = ifelse(sig$value > 0, 1L,
                                  ifelse(sig$value < 0, -1L, 0L)),
        check.names = FALSE
      )
      
      input_file <- file.path(
        g_dir,
        paste0("Input_", matrix_label, "_Maaslin2.csv")
      )
      utils::write.csv(trend_df, input_file, row.names = FALSE)
      
      feats_for_box <- intersect(trend_df$Element, colnames(Mat))
      if (length(feats_for_box) > 0){
        box_png <- file.path(
          g_dir,
          paste0(g_safe, "_Maaslin2_box.png")
        )
        plot_group_box(
          Mat,
          feats_for_box,
          in_group_vec = in_clade_ids,
          group_label  = paste0("Clade_", clade_name),
          out_png      = box_png
        )
      }
      
      sig_feats   <- intersect(trend_df$Element, colnames(Mat))
      ordered_ids <- c(in_clade_ids, setdiff(rownames(Mat), in_clade_ids))
      mat_sig <- as.matrix(Mat[ordered_ids, sig_feats, drop = FALSE])
      if (nrow(mat_sig) >= 2 && ncol(mat_sig) >= 1){
        mat_sig_z <- zscore_rows(mat_sig)
        utils::write.csv(
          data.frame(SampleID = rownames(mat_sig_z), mat_sig_z, check.names = FALSE),
          file.path(g_dir, "zscore_matrix_Maaslin2.csv"),
          row.names = FALSE
        )
        hc_rows <- stats::hclust(stats::dist(mat_sig_z))
        cl_lab  <- stats::cutree(hc_rows, k = 2)
        utils::write.csv(
          data.frame(SampleID = names(cl_lab),
                     Cluster  = cl_lab,
                     check.names = FALSE),
          file.path(g_dir, "row_clusters_k2_Maaslin2.csv"),
          row.names = FALSE
        )
      }
      
      next
    }
    
    message("    - Unknown library '", library_name, "'; skipping TREND for this clade.")
  }
  invisible(TRUE)
}

# ---------------------------------------------------------
# 6. Build jobs from methods.txt
# ---------------------------------------------------------

jobs <- apply(methods_df, 1, function(row){
  file_str  <- as.character(row[["File"]])
  method    <- as.character(row[["Method"]])
  boot      <- suppressWarnings(as.integer(row[["Boot"]]))
  lib_name  <- as.character(row[["Library"]])
  tree_raw  <- as.character(row[["Tree"]])
  
  if (!(method %in% valid_methods)) {
    stop("Invalid method in methods.txt: ", method)
  }
  
  list(
    file_raw     = file_str,
    file         = resolve_path(file_str),
    method       = method,
    library      = lib_name,
    matrix_label = matrix_label_from_file(file_str),
    tree_raw     = tree_raw,
    tag          = tools::file_path_sans_ext(basename(file_str)),
    nboot        = if (is.na(boot)) 0L else boot
  )
})

# ---------------------------------------------------------
# 7. MAIN LOOP
# ---------------------------------------------------------

for (i in seq_along(jobs)){
  jb <- jobs[[i]]
  
  file_path   <- jb$file
  file_raw    <- jb$file_raw
  method      <- jb$method
  lib_name    <- jb$library
  matrix_label<- jb$matrix_label
  tag         <- jb$tag
  nboot       <- jb$nboot
  tree_raw    <- jb$tree_raw
  
  # resolve matrix file (allow missing extension)
  if (!file.exists(file_path)) {
    alt_path <- file_path
    if (!grepl("\\.[A-Za-z0-9]+$", basename(file_raw))) {
      alt_path <- resolve_path(paste0(file_raw, ".csv"))
    }
    if (!identical(alt_path, file_path) && file.exists(alt_path)) {
      message("  (resolved file via .csv extension: ", alt_path, ")")
      file_path <- alt_path
    } else {
      warning("Skipping job ", i, ": input file not found: ",
              file_path,
              if (!identical(alt_path, file_path)) paste0(" and ", alt_path) else "",
              " (from methods.txt row ", i + 1, ")")
      next
    }
  }
  
  message("\n=== JOB ", i, " ===")
  message("File    : ", file_path)
  message("Method  : ", method)
  message("Library : ", lib_name)
  message("Matrix  : ", matrix_label)
  message("Boot    : ", nboot)
  
  # output directory: default = alongside CSV
  if (!is.null(args$`out-root`) && nchar(args$`out-root`) > 0){
    outdir_root <- normalizePath(args$`out-root`, mustWork = FALSE)
  } else {
    outdir_root <- dirname(normalizePath(file_path, mustWork = TRUE))
  }
  outdir <- file.path(outdir_root, paste0(tag, "_", method))
  ensure_dir(outdir)
  message("Outdir  : ", outdir)
  
  # load matrix: rows = samples, cols = features
  otu <- utils::read.csv(file_path, row.names = 1,
                         check.names = FALSE, stringsAsFactors = FALSE)
  all_samples  <- rownames(otu)
  targeted_set <- intersect(all_samples, target_yes)
  
  if (length(targeted_set) < thr_min_targeted){
    message("  ⚠ Fewer targeted (Y) samples than min_targeted; clades may be empty.")
  }
  
  methods_to_run <- if (method == "MMU") phylo_methods else method
  need_tree <- any(methods_to_run %in% phylo_methods)
  
  # resolve tree for this job (if needed)
  ref_tree <- NULL
  tree_path_job <- NA_character_
  if (need_tree){
    tree_path_job <- resolve_tree_path(tree_raw)
    if (is.na(tree_path_job) || !file.exists(tree_path_job)){
      if (!is.null(global_tree_path) && nchar(global_tree_path)){
        message("  Using global --tree for phylogenetic method(s).")
        tree_path_job <- global_tree_path
      } else {
        warning("Skipping job ", i,
                ": phylogenetic method requires a tree, but neither Tree column nor --tree gave a valid file.")
        next
      }
    }
    ref_tree <- ape::read.tree(tree_path_job)
    message("Tree    : ", tree_path_job)
  }
  
  for (m in methods_to_run){
    message("  -> Running method: ", m)
    
    do_boot <- (m != "Bray" && nboot > 0)
    tree_res <- run_tree_analysis(
      method    = m,
      data      = otu,
      ref_tree  = ref_tree,
      do_boot   = do_boot,
      nboot     = nboot,
      outdir    = outdir,
      outprefix = "run"
    )
    
    clade_info <- find_clades_global(
      tree         = tree_res$tree,
      tag          = tag,
      method       = m,
      outdir       = outdir,
      min_targeted = thr_min_targeted,
      max_clade    = thr_max_clade,
      max_others   = thr_max_others,
      targeted_set = targeted_set
    )
    
    if (!is.null(tree_res$tree)){
      hl_file <- file.path(outdir, paste0("run_", m, "_highlighted.jpeg"))
      plot_highlighted_tree(
        tree              = tree_res$tree,
        targeted_set      = targeted_set,
        contamination_set = clade_info$contam_tips,
        outfile           = hl_file,
        tag               = tag,
        method            = m
      )
    }
    
    # clade TREND: limma or MaAsLin2
    run_trend_for_job(
      otu          = otu,
      clade_info   = clade_info,
      outdir       = outdir,
      tag          = tag,
      method       = m,
      matrix_label = matrix_label,
      library_name = lib_name
    )
  }
}

message("\n✓ All jobs complete (SampleTree + clade TREND via limma / MaAsLin2 + boxplots).")

# ---- Merge all Input_*.csv in a group folder into ONE file named by group ----
# Output columns: Element, Observed Shift   (no Source). Conflicts => 0.
merge_group_inputs <- function(group_dir) {
  files <- list.files(group_dir, pattern = "^Input_.*\\.csv$", full.names = TRUE)
  if (length(files) == 0) return(invisible(NULL))
  
  L <- lapply(files, function(f) {
    x <- tryCatch(read.csv(f, check.names = FALSE), error = function(e) NULL)
    if (is.null(x) || nrow(x) == 0) return(NULL)
    x <- x[, intersect(c("Element", "Observed Shift"), names(x)), drop = FALSE]
    if (!all(c("Element","Observed Shift") %in% names(x))) return(NULL)
    x$Element <- as.character(x$Element)
    x[["Observed Shift"]] <- suppressWarnings(as.integer(x[["Observed Shift"]]))
    x
  })
  L <- Filter(Negate(is.null), L)
  if (length(L) == 0) return(invisible(NULL))
  
  merged <- dplyr::bind_rows(L) %>%
    dplyr::group_by(Element) %>%
    dplyr::summarise(
      `Observed Shift` = {
        vals <- unique(na.omit(.data[["Observed Shift"]]))
        if (length(vals) == 1) as.integer(vals) else 0L
      },
      .groups = "drop"
    ) %>%
    dplyr::arrange(Element)
  
  gname <- sub("^group_", "", basename(group_dir))
  out_file <- file.path(group_dir, paste0("Input_MERGED_", gname, ".csv"))
  write.csv(merged, out_file, row.names = FALSE)
  invisible(TRUE)
}

# Sweep all group_* dirs and merge
finalize_all_merges <- function(out_root) {
  if (!dir.exists(out_root)) return(invisible(NULL))
  grp_dirs <- list.dirs(out_root, full.names = TRUE, recursive = FALSE)
  grp_dirs <- grp_dirs[grepl("^group_", basename(grp_dirs))]
  invisible(lapply(grp_dirs, merge_group_inputs))
}

# Collect ONLY the merged inputs (Input_MERGED_*.csv) from each group_* folder
collect_merged_inputs <- function(out_root, dest_folder = "Merged_Group_Inputs") {
  dest_dir <- file.path(out_root, dest_folder)
  ensure_dir(dest_dir)
  
  grp_dirs <- list.dirs(out_root, full.names = TRUE, recursive = FALSE)
  grp_dirs <- grp_dirs[grepl("^group_", basename(grp_dirs))]
  
  for (gd in grp_dirs) {
    merged <- list.files(gd, pattern = "^Input_MERGED_.*\\.csv$", full.names = TRUE)
    if (length(merged) == 0) next
    for (f in merged) {
      file.copy(f, file.path(dest_dir, basename(f)), overwrite = TRUE)
    }
  }
  invisible(dest_dir)
}
